package com{	import flash.display.DisplayObject;	import flash.display.GradientType;	import flash.display.Loader;	import flash.display.LoaderInfo;	import flash.display.MovieClip;	import flash.display.SpreadMethod;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.filters.BlurFilter;	import flash.geom.Matrix;	import flash.net.URLRequest;	import flash.display.Bitmap;	import flash.display.BitmapData;	public dynamic class Tiltshift extends MovieClip	{		private var image1:*;		private var image2:*;		private var bool_im1:Boolean = new Boolean (false);		private var bool_im2:Boolean = new Boolean (false);		private var blurVal:int = 0;		private var sizeFoc:Number = 0;		private var posFoc:Number = 0;		private var angleFoc:Number = 0;				private var mc_content:MovieClip = new MovieClip();		private var final_mask:MovieClip = new MovieClip();				private var mask1:Sprite = new Sprite();		private var colors1:Array = [0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000];		private var alphas1:Array = [1, 0.5, 0,0, 0.5, 1];		private var ratios1:Array = [0, 60, 120, 135, 195, 255];		private var matrix1:Matrix = new Matrix();				private var mask2:Sprite = new Sprite();		private var colors2:Array = [0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000];		private var alphas2:Array = [0, 0.7, 1, 1, 0.7, 0];		private var ratios2:Array = [0, 65, 127, 127, 190, 255];		private var matrix2:Matrix = new Matrix();				public function Tiltshift(size:Number = 0.5, position:Number = 0.5, blur:int = 10, angle:Number = Math.PI/2, im_type:String = "url", im:* = null)		{			blurVal = blur;			posFoc = position;			sizeFoc = size;			angleFoc = angle * Math.PI/180;						if(im_type == "url")			{				image1 = new Loader();				image1.name = "im1";				image1.contentLoaderInfo.addEventListener(Event.COMPLETE, f_init);				image1.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, f_error);				image1.load(new URLRequest(im as String));								image2 = new Loader();				image2.name = "im2";				image2.contentLoaderInfo.addEventListener(Event.COMPLETE, f_init);				image2.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, f_error);				image2.load(new URLRequest(im as String));			}			else if(im_type == "asset")			{				//myImage:Bitmap = new Bitmap(myBitmapDataObject);				image1 = new Bitmap(im);				image2 = new Bitmap(im);				//image1 = im as BitmapData;				//image2 = im as BitmapData;								//image1.name = 'im1';				//image2.name = 'im2';								bool_im1 = true;				bool_im2 = true;								f_init(null);			}		}				private function f_error(evt:IOErrorEvent):void		{			trace("Error : "+evt.text);		}				private function f_init(evt:Event):void		{			if(evt!=null) this["bool_"+(evt.currentTarget as LoaderInfo).loader.name] = true;			if((bool_im1 == true && bool_im2 == true))			{				//trace("image: " + image1.height);				var temp1:int = map(sizeFoc, 0, 1, 0, 255);				var temp2:int = map(posFoc, 0, 1, 0, 255);				var quart:int = 255/4;								var ratio_1:int = 0;				var ratio_2:int = 0;				var ratio_3:int = 0;				var ratio_4:int = 0;								ratio_1 = temp2 - temp1/2;				ratio_2 = temp2 - temp1/4;				ratio_3 = temp2 + temp1/4;				ratio_4 = temp2 + temp1/2;								ratio_1 = constrain(ratio_1, 0, 255);				ratio_2 = constrain(ratio_2, 0, 255);				ratio_3 = constrain(ratio_3, 0, 255);				ratio_4 = constrain(ratio_4, 0, 255);								//trace(ratio_1 + " " + ratio_2 + " " + ratio_3 + " " + ratio_4 + " " + angleFoc);								mask1 = new Sprite();				colors1 = [0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000];				alphas1 = [1, 0.5, 0, 0, 0.5, 1];				ratios1 = [0, ratio_1, ratio_2, ratio_3, ratio_4, 255];				matrix1 = new Matrix();								mask2 = new Sprite();				colors2 = [0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000];				alphas2 = [0.1, 0.9, 1, 1, 0.9, 0.1];				ratios2 = [0, ratio_1, ratio_2, ratio_3, ratio_4, 255];				matrix2 = new Matrix();								matrix1.createGradientBox(image1.width,image1.height, angleFoc, 0, 0);				mask1.graphics.beginGradientFill(GradientType.LINEAR,					colors1,					alphas1,					ratios1,					matrix1);								mask1.graphics.drawRect(0, 0, image1.width, image1.height);				mask1.graphics.endFill();								matrix2.createGradientBox(image2.width, image2.height, angleFoc, 0, 0);				mask2.graphics.beginGradientFill(GradientType.LINEAR,					colors2,					alphas2,					ratios2,					matrix2);								mask2.graphics.drawRect(0, 0, image2.width, image2.height);				mask2.graphics.endFill();								image1.cacheAsBitmap = true;				image2.cacheAsBitmap = true;				mask1.cacheAsBitmap = true;				mask2.cacheAsBitmap = true;								image2.filters = [new BlurFilter(blurVal,blurVal,1)];				image2.mask = mask1;				image1.mask = mask2;								mc_content.addChild(mask1);				mc_content.addChild(mask2);								final_mask.graphics.beginFill(0);				final_mask.graphics.drawRect(blurVal,blurVal,image1.width-(blurVal*2),image1.height-(blurVal*2));								mc_content.addChild(image1);				mc_content.addChild(image2);								mc_content.cacheAsBitmap = true;				final_mask.cacheAsBitmap = true;								//to avoid the transparent border				mc_content.mask = final_mask;				addChild(final_mask);				addChild(mc_content);								dispatchEvent(new Event("LOADED",true));			}		}				public function f_update():void		{					}				private function map(v:Number, a:Number, b:Number, x:Number = 0, y:Number = 1):Number {			return (v == a) ? x : (v - a) * (y - x) / (b - a) + x;		}				private function constrain(v:Number, a:Number, b:Number):Number		{			if(v<a)return a;			else if(v>b)return b;			else return v;		}	}}